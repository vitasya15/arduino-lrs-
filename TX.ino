/*   Данный скетч делает следующее: передатчик (TX) отправляет массив
 *   данных, который генерируется согласно показаниям с кнопки и с 
 *   двух потенциомтеров. Приёмник (RX) получает массив, и записывает
 *   данные на реле, сервомашинку и генерирует ШИМ сигнал на транзистор.
    by AlexGyver 2016
    модерн бу виталик
*/

#include <SPI.h>          // библиотека для работы с шиной SPI
#include "nRF24L01.h"     // библиотека радиомодуля
#include "RF24.h"         // ещё библиотека радиомодуля

#include <Adafruit_SSD1306.h>
#include <splash.h>

#include <Wire.h>
#include <Adafruit_GFX.h>
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32 

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
RF24 radio(9, 10); // "создать" модуль на пинах 9 и 10 Для Уно

byte address[][6] = {"1Node", "2Node", "3Node", "4Node", "5Node", "6Node"}; //возможные номера труб

byte potx = A0;
byte poty = A1;
byte potz = A2;
byte potv = A3;
byte MenuPos = 0;
bool butt;
bool armtumb;    //тумблер без возврата
unsigned long last_press;

byte transmit_data[3]; //массив, хранящий данные

static const PROGMEM uint8_t logo[] = {                                                //логотип
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x08, 0x01, 0x03, 0x03, 0xff, 0xc0, 0x06, 0x00, 0x07, 0xe0, 0x08, 0x01, 0x00, 0x18, 0x00, 
    0x00, 0x14, 0x02, 0x84, 0x84, 0x00, 0x20, 0x0f, 0x00, 0x1c, 0x38, 0x14, 0x02, 0x80, 0x3c, 0x00, 
    0x00, 0x14, 0x02, 0x84, 0x86, 0x00, 0x60, 0x19, 0x80, 0x31, 0x8c, 0x14, 0x02, 0x80, 0x66, 0x00, 
    0x00, 0x14, 0x02, 0x84, 0x83, 0xc3, 0xc0, 0x30, 0xc0, 0x66, 0x66, 0x14, 0x02, 0x80, 0xc3, 0x00, 
    0x00, 0x14, 0x02, 0x84, 0x80, 0x66, 0x00, 0x66, 0x60, 0x48, 0x12, 0x12, 0x04, 0x81, 0x99, 0x80, 
    0x00, 0x14, 0x02, 0x84, 0x80, 0x24, 0x00, 0x49, 0x20, 0x4c, 0x0c, 0x19, 0x0c, 0x81, 0x24, 0x80, 
    0x00, 0x14, 0x02, 0x84, 0x80, 0x24, 0x00, 0xd0, 0xb0, 0x66, 0x00, 0x0c, 0xf9, 0x83, 0x42, 0xc0, 
    0x00, 0x12, 0x04, 0x84, 0x80, 0x24, 0x00, 0x90, 0x90, 0x33, 0xe0, 0x06, 0x01, 0x02, 0x42, 0x40, 
    0x00, 0x1a, 0x05, 0x84, 0x80, 0x24, 0x01, 0x90, 0x98, 0x18, 0x38, 0x03, 0xf9, 0x86, 0x42, 0x60, 
    0x00, 0x09, 0x09, 0x04, 0x80, 0x24, 0x01, 0x0f, 0x08, 0x0f, 0x8c, 0x00, 0x04, 0x84, 0x3c, 0x20, 
    0x00, 0x0d, 0x0b, 0x04, 0x80, 0x24, 0x01, 0x20, 0x48, 0x00, 0xe6, 0x08, 0x02, 0x84, 0x81, 0x20, 
    0x00, 0x04, 0x92, 0x04, 0x80, 0x24, 0x01, 0x5f, 0xa8, 0x30, 0x32, 0x14, 0x06, 0x85, 0x7e, 0xa0, 
    0x00, 0x06, 0x66, 0x04, 0x80, 0x24, 0x01, 0x40, 0x28, 0x48, 0x12, 0x12, 0x04, 0x85, 0x00, 0xa0, 
    0x00, 0x03, 0x0c, 0x04, 0x80, 0x24, 0x01, 0x40, 0x28, 0x66, 0x66, 0x0a, 0x09, 0x05, 0x00, 0xa0, 
    0x00, 0x01, 0x98, 0x04, 0x80, 0x24, 0x01, 0x40, 0x28, 0x31, 0x8c, 0x09, 0xf3, 0x05, 0x00, 0xa0, 
    0x00, 0x00, 0xf0, 0x04, 0x80, 0x24, 0x01, 0x40, 0x28, 0x1c, 0x38, 0x04, 0x06, 0x05, 0x00, 0xa0, 
    0x00, 0x00, 0x60, 0x03, 0x00, 0x18, 0x00, 0x80, 0x10, 0x07, 0xe0, 0x03, 0xfc, 0x02, 0x00, 0x40, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x61, 0x86, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x92, 0x49, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x92, 0x49, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x93, 0x8e, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x92, 0x48, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x62, 0x48, 0x40, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
 
static const PROGMEM uint8_t dan[] = {                     // контур квадратов
  0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0xc0, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00
};

void setup() {
  
pinMode (2, OUTPUT);
digitalWrite (2,HIGH);
pinMode(5, INPUT_PULLUP);

pinMode(7, INPUT_PULLUP); //тумблер без возврата
//pinMode(8, INPUT); //тумблер с возвратом
 
  display.clearDisplay();
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);

  display.clearDisplay();
  display.drawBitmap(0, 0, logo, 128, 32, 1);
  display.display();
  delay (1600);
  display.clearDisplay();
  Serial.begin(9600); //открываем порт для связи с ПК

  radio.begin(); //активировать модуль
  radio.setAutoAck(1);         //режим подтверждения приёма, 1 вкл 0 выкл
  radio.setRetries(0, 15);    //(время между попыткой достучаться, число попыток)
  radio.enableAckPayload();    //разрешить отсылку данных в ответ на входящий сигнал
  radio.setPayloadSize(32);     //размер пакета, в байтах

  radio.openWritingPipe(address[0]);   //мы - труба 0, открываем канал для передачи данных
  radio.setChannel(0x60);  //выбираем канал (в котором нет шумов!)

  radio.setPALevel (RF24_PA_MAX); //уровень мощности передатчика. На выбор RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX
  radio.setDataRate (RF24_250KBPS); //скорость обмена. На выбор RF24_2MBPS, RF24_1MBPS, RF24_250KBPS
  //должна быть одинакова на приёмнике и передатчике!
  //при самой низкой скорости имеем самую высокую чувствительность и дальность!!

  radio.powerUp(); //начать работу
  radio.stopListening();  //не слушаем радиоэфир, мы передатчик

  
}

void loop() {
  
  armtumb = !digitalRead(7);
  Serial.print (armtumb);

  //if ( armtumb == 1 ) and ( transmit_data[0] < 4)
 
  
  transmit_data[0] =  map(analogRead (potx), 0, 888,0, 180);
  //transmit_data[0] =  map(analogRead (potx), 0, 880, 0, 180);
  //transmit_data[0] =  map(analogRead (potx), 0, 800, 0, 160);
  transmit_data[1] =  map(analogRead (poty), 0, 800, 0, 180);
  transmit_data[2] =  map(analogRead (potz), 0, 800, 0, 180);
//int v =  map(analogRead (potv), 0, 800, 0, 180);
  transmit_data[3] =  map(analogRead (potv), 0, 800, 0, 180);
 
 transmit_data[0] = constrain (transmit_data[0], 0, 180);
 transmit_data[1] = constrain (transmit_data[1], 0, 180);
 transmit_data[2] = constrain (transmit_data[2], 0, 180);
// v = constrain (v, 0, 180);
 transmit_data[3] = constrain (transmit_data[3], 0, 180);
 // radio.powerUp(); // включить передатчик


  radio.powerDown(); //выключить передатчик

  
if (( armtumb == 1 ) and ( transmit_data[0] < 4))
  {
  radio.powerUp(); // включить передатчик
  radio.write(&transmit_data, sizeof(transmit_data)); // отправляет массив 
  }

/*Serial.print (transmit_data[0]);
Serial.print( " x           " );
Serial.print (transmit_data[1]);
Serial.print ( " y               " );
Serial.print (transmit_data[2]);
Serial.println ( " z               " );
*/

butt = !digitalRead(5);  // считаем текущее положение кнопки
if (butt == 1 and (millis()- last_press) > 200)
{  
  if (MenuPos <1) 
  {
    MenuPos +=1;
  }  
  else{
    MenuPos = 0;
  }
last_press = millis();
}
    
if (MenuPos == 0)
{
display.clearDisplay();
display.setTextSize(2);
display.setTextColor(WHITE);

display.setCursor(0,0);
display.print(transmit_data[0]);
display.setCursor(40,0);
display.print("X");

display.setCursor(0,16);
display.print(transmit_data[1]);
display.setCursor(40,16);
display.print("Y");

display.setCursor(64,0);
display.print(transmit_data[2]);
display.setCursor(104,0);
display.print("Z");

display.setCursor(64,16);
display.print(transmit_data[3]);
display.setCursor(104,16);
display.print("V");

display.display();
display.clearDisplay();
}
else if(MenuPos == 1)
{
display.clearDisplay();
display.drawBitmap(0, 0, dan, 128, 32, 1);
display.display();
display.clearDisplay();
}
}

//else:
//  print();
